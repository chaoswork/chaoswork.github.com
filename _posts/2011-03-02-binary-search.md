---
layout: post
meta: 
  views: "6"
type: post
tags: 
- Algorithm
- Binary Search

title: 二分查找

published: true
status: publish
---
以前学的时候也没好好研究，只是大概知道思想，昨天写程序的时候发现bug了，十分惭愧，结果在网上发现了这样资料：

>二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。一开始，范围覆盖整个数组。将数组的中间项与T进行比较，可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。 
>多数程序员都觉得只要理解了上面的描述，写出代码就不难了；但事实并非如此。如果你不认同这一点，最好的办法就是放下书本，自己动手写一写。试试吧。 
>我在贝尔实验室和IBM的时候都出过这道考题。那些专业的程序员有几个小时的时间，可以用他们选择的语言把上面的描述写出来；写出高级伪代码也可以。考试结束后，差不多所有程序员都认为自己写出了正确的程序。于是，我们花了半个钟头来看他们编写的代码经过测试用例验证的结果。几次课，一百多人的结果相差无几：90%的程序员写的程序中有bug（我并不认为没有bug的代码就正确）。 
>我很惊讶：在足够的时间内，只有大约10%的专业程序员可以把这个小程序写对。但写不对这个小程序的还不止这些人：高德纳在《计算机程序设计的艺术 第3卷 排序和查找》第6.2.1节的“历史与参考文献”部分指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序。 
>			-- 乔恩.本特利，《编程珠玑（第1版）》第35-36页

只有10%的程序员可以写出正确的二分查找程序，看来我还不属于这10%。

当时错误的原因很简单，就是一个小小的bug陷入的死循环：

{% highlight c++ %}
int bSearch(vector<int>a,int x)
{
    int l=0,r=a.size()-1;
    int mid=(l+r)/2;
    while(l<r)
    {
        if(a[mid]<x) l=mid;
        else if(a[mid]>x) r=mid;
        else break;
        mid=(l+r)/2;
    }
    return mid;
}
{% endhighlight %}

