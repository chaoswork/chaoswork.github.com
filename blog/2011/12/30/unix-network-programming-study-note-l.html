<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Unix Network Programming 读书笔记1:daytimetcp注解</title>
  <meta name="description" content="最近在看Stevens大师的《Unix Network Programming：V1》.虽然已经写的十分清晰，但是有些地方对于我这样的新手还是很吃力，可能第一章只是进行介绍，详细讲解在后面。下面是我第一章的学习笔记。环境编译：由于本书已经有第三版，所以我到网上下载了第三版的源码，README已经写的很清楚了，整个...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://chaos.work/blog/2011/12/30/unix-network-programming-study-note-l">
  <link rel="alternate" type="application/rss+xml" title="Chaos.Work" href="http://chaos.work/feed.xml">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Chaos.Work</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Unix Network Programming 读书笔记1:daytimetcp注解</h1>
    <p class="post-meta"><time datetime="2011-12-30T16:17:44+08:00" itemprop="datePublished">Dec 30, 2011</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">huangchao</span></span></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>最近在看Stevens大师的《Unix Network Programming：V1》.虽然已经写的十分清晰，但是有些地方对于我这样的新手还是很吃力，可能第一章只是进行介绍，详细讲解在后面。<br />
下面是我第一章的学习笔记。<br />
环境编译：<br />
由于本书已经有第三版，所以我到网上下载了第三版的源码，README已经写的很清楚了，整个编译过程轻松加愉快。其实主要是为了生成libunp.a这个库文件。<br />
简单的时间客户端代码<br />
daytimetcpcli.c</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include "unp.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">"usage: a.out &lt;IPaddress&gt;"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"socket error"</span><span class="p">);</span>
    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> <span class="cm">/* daytime server */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">"inet_pton error for %s"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"connect error"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">recvline</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* null terminate */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">"fputs error"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"read error"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>    </code></pre></figure>

<p>只有27行，麻雀虽小，五脏俱全。下面进行详细的介绍。<br />
第1行，包含unp.h的头文件，这个头文件是作者自己写的，这里面包含了诸多的系统头文件以及网U络编程所需要的头文件。<br />
第5行，sockfd,全称应该是socket file descriptor，用整形表示，是用来保存socket函数返回值，其余的socket相关操作都要通过这个文件描述符来找到我们生成的socket。n用来保存后面read函数读到的字符流的长度。<br />
第6行，recvline，用来保存字符串。<br />
第7行，servaddr，是个sockaddr_in类型的结构体，书中整个结构体声明如下：</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">in_addr</span><span class="p">{</span>
    <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="c1">//32bit表示的ip地址，一个unsigned int
</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">sin_len</span><span class="p">;</span> <span class="c1">//OSI协议的支持
</span>    <span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="c1">//协议族，这里是AF_INET
</span>    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="c1">//16bit端口
</span>    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="c1">//ipv4地址,32bit
</span>    <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">//为了和sockaddr结构大小一样进行的冗余数据
</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">sockaddr</span><span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">sa_len</span><span class="p">;</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="c1">//14字节的协议
</span><span class="p">};</span></code></pre></figure>

<p>由于作者采用的是通用的unix协议，ubuntu等linux版本中有了一些变化，但是仍然遵循POSIX标准。<!-- more --><br />
ubuntu中是这个样子的：</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define __SOCKADDR_COMMON(sa_prefix) 
</span><span class="n">sa_family_t</span> <span class="n">sa_prefix</span><span class="err">##</span><span class="n">family</span> 
<span class="c1">//宏定义的函数，##代表字符连接，比如下面代码中的__SOCKADDR_COMMON (sin_);就相当于sin_family_t sin_family;
</span> 
<span class="cm">/* Internet address. */</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">in_addr_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">in_addr</span>
<span class="p">{</span>
     <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* 
Structure describing an Internet socket address. */</span>
<span class="k">struct</span> 
<span class="n">sockaddr_in</span>
<span class="p">{</span>
     <span class="n">__SOCKADDR_COMMON</span> <span class="p">(</span><span class="n">sin_</span><span class="p">);</span>
 
    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* Port number. */</span>
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* Internet address. */</span>
    <span class="cm">/* Pad to size of `struct sockaddr'. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">)</span> <span class="o">-</span> 
    <span class="n">__SOCKADDR_COMMON_SIZE</span> <span class="o">-</span> 
    <span class="k">sizeof</span> <span class="p">(</span><span class="n">in_port_t</span><span class="p">)</span> <span class="o">-</span> 
    <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)];</span>
<span class="p">};</span>
<span class="cm">/* Structure describing a generic socket 
address. */</span>
<span class="k">struct</span> <span class="n">sockaddr</span>
<span class="p">{</span>
     <span class="n">__SOCKADDR_COMMON</span> <span class="p">(</span><span class="n">sa_</span><span class="p">);</span> <span class="cm">/* Common data: address family and length. */</span>
     <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* Address data. */</span>
<span class="p">};</span></code></pre></figure>

<p>可以看出书中sockaddr.sa_len和sockaddr_in.sin_len在ubuntu的版本中被去掉了。其余的结构都是一样的。<br />
sockaddr_in是IPv4套接口地址的结构，也叫”Internet socket address structure”，POSIX标准中要求其必须含有3个成员，sin_family,sin_port和sin_addr，后两个我们已经知道了他们的大小，sin_family的类型为unsiged short，可能会随着操作系统的不同会有所改变。<br />
第10行，socket函数<br />
用来创建一个新的socket，如果成功，则返回socket的文件描述符，如果失败，则可以根据返回的负数来查询相应的错误。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Create a new socket of type TYPE in domain DOMAIN, using protocol 
PROTOCOL. If PROTOCOL is zero, one is chosen automatically. 
Returns a file descriptor for the new socket, or -1 for errors. 
*/</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">socket</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__protocol</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span></code></pre></figure>

<p>domain参数表示通信的域，一般是指定通信的协议族，比如PF_INET/AF_INET表示IPv4协议，PF_INET6/AF_INET6表示IPv6协议，PF_UNIX/PF_LOCAL/AF_UNIX/AF_LOCAL UNIX表示进程通信协议；type表示socket的类型，比如SOCK_STREAM 提供双向连续且可信赖的数据流，即TCP，SOCK_DGRAM 使用不连续不可信赖的数据包连接，UDP；protocol指定在socket中使用的特定的协议。一般来讲，只存在一个单独的协议来支持给定的协议族中特定的socket类型，<br />
在这种情况下protocol可以用0来代表默认值。然而，有可能很多协议都会存在，在这种情况下特定的协议必须在这种方式下指定。我去源码中找了一下，发现了下面的协议编号。可以根据网络的环境进行选择。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="cm">/* Standard well-defined IP protocols. */</span>
    <span class="k">enum</span> <span class="p">{</span>
    <span class="n">IPPROTO_IP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/*     Dummy protocol for TCP */</span>
    <span class="n">IPPROTO_ICMP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Internet Control Message     Protocol */</span>
    <span class="n">IPPROTO_IGMP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* Internet Group Management Protocol     */</span>
    <span class="n">IPPROTO_IPIP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* IPIP tunnels (older KA9Q tunnels use 94)     */</span>
    <span class="n">IPPROTO_TCP</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* Transmission Control Protocol */</span>
    <span class="n">IPPROTO_EGP</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/* Exterior Gateway Protocol */</span>
    <span class="n">IPPROTO_PUP</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="cm">/* PUP protocol */</span>
    <span class="n">IPPROTO_UDP</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="cm">/* User Datagram Protocol */</span>
    <span class="n">IPPROTO_IDP</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="cm">/* XNS IDP protocol */</span>
    <span class="n">IPPROTO_DCCP</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span> <span class="cm">/* Datagram Congestion Control Protocol */</span>
    <span class="n">IPPROTO_RSVP</span> <span class="o">=</span> <span class="mi">46</span><span class="p">,</span> <span class="cm">/* RSVP protocol */</span>
    <span class="n">IPPROTO_GRE</span> <span class="o">=</span> <span class="mi">47</span><span class="p">,</span> <span class="cm">/* Cisco GRE tunnels (rfc 1701,1702) */</span>
    <span class="n">IPPROTO_IPV6</span> <span class="o">=</span> <span class="mi">41</span><span class="p">,</span> <span class="cm">/* IPv6-in-IPv4 tunnelling */</span>
    <span class="n">IPPROTO_ESP</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="cm">/* Encapsulation Security Payload protocol */</span>
    <span class="n">IPPROTO_AH</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span> <span class="cm">/* Authentication Header protocol*/</span>
    <span class="n">IPPROTO_BEETPH</span> <span class="o">=</span> <span class="mi">94</span><span class="p">,</span> <span class="cm">/* IP option pseudo header for BEET */</span>
    <span class="n">IPPROTO_PIM</span> <span class="o">=</span> <span class="mi">103</span><span class="p">,</span> <span class="cm">/* Protocol Independent Multicast */</span>
    <span class="n">IPPROTO_COMP</span> <span class="o">=</span> <span class="mi">108</span><span class="p">,</span> <span class="cm">/* Compression Header protocol */</span>
    <span class="n">IPPROTO_SCTP</span> <span class="o">=</span> <span class="mi">132</span><span class="p">,</span> <span class="cm">/* Stream Control Transport Protocol */</span>
    <span class="n">IPPROTO_UDPLITE</span> <span class="o">=</span> <span class="mi">136</span><span class="p">,</span> <span class="cm">/* UDP-Lite (RFC 3828) */</span>
    <span class="n">IPPROTO_RAW</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="cm">/* Raw IP packets */</span>
    <span class="n">IPPROTO_MAX</span>
    <span class="p">};</span>
    </code></pre></figure>

<p>第12行，bzero函数不知道是不是标准c的一部分，这个函数就是给一段字符串赋0值，比如</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">bzero</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="o">//</span><span class="err">相当于</span><span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span></code></pre></figure>

<p>这一行代码的作用是将servaddr中的内容全部置零。<br />
第13行，指定通信地址的协议族。<br />
第14行，指定通信地址的端口。这里有个htons函数，和这个函数类似的函数还有htonl,ntohs,ntohl,这一系列函数中，h代表host，也就是主机，to是转换，n是network，网络，l代表long，s代表short，这里的host和network应该怎么理解，这其实牵扯到主机字节顺序(Host Byte Order)和网络字节顺序(Network Byte Order)这两个概念有关。现在的CPU有两大派系，PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用big endian方式存储数据，而x86系列则采用little endian方式存储数据。Big-Endian表示高字节存放在最后(Big End first)，Little-Endian表示低字节放在最后(Litter End first)，举例来说：比如一个数字0x12345678,Big-Endian形式下这4个字节在内存中存放的顺序是<br />
|12|34|56|78|<br />
而Little-Endian形式的为<br />
|78|56|34|12|<br />
网络上的传输采用的是Big-Endian类型的，所以将本地的数字在进行网络传输之前要先进行转换，利用的就是上面提到的几个函数。<br />
第15行，赋值通信的ip地址。这里有个函数<code class="highlighter-rouge">inet_pton(int family,const char * strptr,void * addrptr);</code>就是将点分十进制串转换成网络字节序二进制值，同样要指定下协议族。<br />
第17行，<code class="highlighter-rouge">connect(sockfd,(SA*)&amp;servaddr,sizeof(servaddr))</code>，建立一个指定地址的连接。连接的服务器地址为servaddr。这里先给出它的声明<code class="highlighter-rouge">int connect(int sockfdFD,struct sockaddr*,int addrlength);</code><br />
这里就有一个问题，我们是把一个sockaddr_in类型的数据强制转换成了sockaddr类型。其实sockaddr的存储结构和sockaddr_in的存储结构是一样的，sockaddr是通用套接口地址结构(Generic Socket Address Structure)，而sockaddr_in可以看作是sockaddr的一个子集，至于后面的in的含义，我猜是internet的意思。这也解释了为什么sockaddr_in中会有冗余的数据，就是为了将结构体的大小设置成和sockaddr相等。而sockaddr.sa_data中数据可以看作是一种协议地址，不同协议所会有差别，这本书主要讲Internet协议。<br />
第19行，read函数其实是系统函数，从指定的文件读取数据，这里的文件描述符是创建socket时返回的描述符，也就是从网络读取。这也反映了在Unix系统中一切都是文件的思想。<br />
剩下的内容都很容易理解了，都是写基本的C语言的语法。<br />
上面的文件只是一个获取服务器时间的客户端代码，那么服务器端肯定要首先有这个服务，服务器端的代码如下：</p>

<p>daytimetcpsrv.c</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include "unp.h" 
#include &lt;time.h&gt; 
</span><span class="kt">int</span> 
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span> 
    <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span> 
    <span class="kt">time_t</span> <span class="n">ticks</span><span class="p">;</span> 
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> <span class="cm">/* daytime server */</span> 
    <span class="n">Bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span> 
    <span class="n">Listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> 
        <span class="n">snprintf</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="s">"%.24srn"</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">));</span> 
        <span class="n">Write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span> 
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span> 
    <span class="p">}</span> 
<span class="p">}</span> </code></pre></figure>

<p>这段代码里面又出现了几个新函数。<br />
第15行，<code class="highlighter-rouge">int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);</code>函数，这个函数将socket绑定到网络地址，对于Internet来说，就是ip地址和端口号，每个socket在正常工作前都要进行这种绑定，那么现在看daytimetcpcli.c中的代码中并没有发现这个函数，原因是这样的，如果你没有手动进行绑定，那么系统会在运行的时候绑定本机地址和一个临时的端口，但是这对于客户来说用那个端口是无所谓的，但是如果服务器绑定了一个临时的端口，客户并不知道是那个端口，就没法连接了，所以服务端要绑定一个特定的端口，并和服务器说，你来连接这个端口，这样才会正常的工作。现在看这个socket绑定的地址和端口都是什么，端口是13，这个号理解，但是地址是INADDR_ANY，这是什么意思？因为有可能我的这个服务器有很多网卡，有很多IP地址，我想不管是那个IP地址接受到的数据，只要是通过13端口连接的，我都处理，这时候就可以通过绑定INADDR_ANY来实现。<br />
第16行，int listen(int sockfd, int backlog)，这个函数是使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。因为当一个socket建立时，默认是主动的，也就是说准备去连接服务器的，但是调用listen后，会将这个socket变成被动，准备接受来自其他socket的连接。一般这个函数只会在服务器端出现。第二个参数是指内核为此套接字排队的最大连接个数。比如很多客户端尝试着连接这个socket，服务器无法快速的完成所有的请求，那么就会维护一个队列。这里指定的值为LISTENQ，这里为1024.<br />
第18行，<code class="highlighter-rouge">int accept(int sockfd, struct sockaddr* addr, socklen_t* len)</code>，接受来自sockaddr的连接，如果成功则返回一个全新的文件描述符，代表与客户的网络连接，后面的代码可以看到怎么处理的这个新的文件描述符，需要注意的是，accept函数默认会阻塞进程，也就是说连接成功后程序才会往下执行。<br />
分析了这两个代码可以基本了解整个连接是怎么建立起来的了：</p>

<ol>
  <li>
    <p>服务器端建立一个标识为listenfd的套接字。</p>
  </li>
  <li>
    <p>将listenfd这个套接字绑定到13端口。</p>
  </li>
  <li>
    <p>将listenfd变成被动的socket接口。</p>
  </li>
  <li>
    <p>利用accept函数让listenfd这个套接字来等待客户的连接，服务器端阻塞。</p>
  </li>
  <li>
    <p>服务器建立标识为sockfd的socket，这个socket并没有手动绑定。系统会用本机地址和一个随机的端口对其绑定。</p>
  </li>
  <li>
    <p>将sockfd这个套接字通过connect与服务器地址相连接。如果连接成功，则read函数准备读取这个sockfd的数据，客户端阻塞。</p>
  </li>
  <li>
    <p>服务器端接收到请求，生成一个新的socket与客户端相连接connfd。</p>
  </li>
  <li>
    <p>服务器通过新生成的socket发送给客户端数据。</p>
  </li>
  <li>
    <p>客户端通过与服务器相连接的socket读取到了数据并显示，结束。</p>
  </li>
</ol>

<p><img src="/images/unp/005_thumb.png" alt="image" />
其实是两台电脑通过socket进行了进程间通信，代码中是通过文件描述符来代表socket的，至于socket的结构以及怎么就能通过这个socket进行数据传输，这些内容有待研究。</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Chaos.Work</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Chaos.Work</li>
          <li><a href="mailto:huangchao.cpp@gmail.com">huangchao.cpp@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/chaoswork"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">chaoswork</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/huangchao"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">huangchao</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>make life
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
