<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Unix Network Programming 读书笔记1:daytimetcp注解</title>
  <meta name="description" content="最近在看Stevens大师的《Unix Network Programming：V1》.虽然已经写的十分清晰，但是有些地方对于我这样的新手还是很吃力，可能第一章只是进行介绍，详细讲解在后面。下面是我第一章的学习笔记。环境编译：由于本书已经有第三版，所以我到网上下载了第三版的源码，README已经写的很清楚了，整个...">


  <link rel="stylesheet" href="/css/tufte.css">	
  

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75587219-1', 'auto');
  ga('send', 'pageview');

  </script>

  <link rel="canonical" href="http://localhost:4000/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/2011/12/30/unix-network-programming-study-note-l.html">
  <link rel="alternate" type="application/rss+xml" title="Chaos.Work" href="http://localhost:4000/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
        <a href="/">Blog</a>
	<a href="http://github.com/chaoswork">Github</a>
	</nav>
</header>

    <article class="group">
      <h1>Unix network programming 读书笔记1:daytimetcp注解</h1>
<p class="subtitle">December 30, 2011</p>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      Macros: {
        e: "\\epsilon",
        xti: "x^{(i)}",
        yti: "y^{(i)}",
        bfy: "{\\bf y}",
        bfx: "{\\bf x}",
        bfg: "{\\bf g}",
        bfbeta: "{\\bf \\beta}",
        tp: "\\tilde p",
        pt: "p_\\theta",
        Exp: "{\\mathbb{E}}",
        Ind: "{\\mathbb{I}}",
        KL: "{\\mathbb{KL}}",
        Dc: "{\\mathcal{D}}",
        Tc: "{\\mathcal{T}}",
        Xc: "{\\mathcal{X}}",
        note: ["\\textcolor{blue}{[NOTE: #1]}",1]
      }
    }
  });
</script>


<p>最近在看Stevens大师的《Unix Network Programming：V1》.虽然已经写的十分清晰，但是有些地方对于我这样的新手还是很吃力，可能第一章只是进行介绍，详细讲解在后面。<br />
下面是我第一章的学习笔记。<br />
环境编译：<br />
由于本书已经有第三版，所以我到网上下载了第三版的源码，README已经写的很清楚了，整个编译过程轻松加愉快。其实主要是为了生成libunp.a这个库文件。<br />
简单的时间客户端代码<br />
daytimetcpcli.c</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include "unp.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">"usage: a.out &lt;IPaddress&gt;"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"socket error"</span><span class="p">);</span>
    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> <span class="cm">/* daytime server */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">"inet_pton error for %s"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"connect error"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">recvline</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* null terminate */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">"fputs error"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"read error"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>    </code></pre></figure>

<p>只有27行，麻雀虽小，五脏俱全。下面进行详细的介绍。<br />
第1行，包含unp.h的头文件，这个头文件是作者自己写的，这里面包含了诸多的系统头文件以及网U络编程所需要的头文件。<br />
第5行，sockfd,全称应该是socket file descriptor，用整形表示，是用来保存socket函数返回值，其余的socket相关操作都要通过这个文件描述符来找到我们生成的socket。n用来保存后面read函数读到的字符流的长度。<br />
第6行，recvline，用来保存字符串。<br />
第7行，servaddr，是个sockaddr_in类型的结构体，书中整个结构体声明如下：</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">in_addr</span><span class="p">{</span>
    <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="c1">//32bit表示的ip地址，一个unsigned int
</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">sin_len</span><span class="p">;</span> <span class="c1">//OSI协议的支持
</span>    <span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="c1">//协议族，这里是AF_INET
</span>    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="c1">//16bit端口
</span>    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="c1">//ipv4地址,32bit
</span>    <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">//为了和sockaddr结构大小一样进行的冗余数据
</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">sockaddr</span><span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">sa_len</span><span class="p">;</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="c1">//14字节的协议
</span><span class="p">};</span></code></pre></figure>

<p>由于作者采用的是通用的unix协议，ubuntu等linux版本中有了一些变化，但是仍然遵循POSIX标准。<!-- more --><br />
ubuntu中是这个样子的：</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define __SOCKADDR_COMMON(sa_prefix) 
</span><span class="n">sa_family_t</span> <span class="n">sa_prefix</span><span class="err">##</span><span class="n">family</span> 
<span class="c1">//宏定义的函数，##代表字符连接，比如下面代码中的__SOCKADDR_COMMON (sin_);就相当于sin_family_t sin_family;
</span> 
<span class="cm">/* Internet address. */</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">in_addr_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">in_addr</span>
<span class="p">{</span>
     <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* 
Structure describing an Internet socket address. */</span>
<span class="k">struct</span> 
<span class="n">sockaddr_in</span>
<span class="p">{</span>
     <span class="n">__SOCKADDR_COMMON</span> <span class="p">(</span><span class="n">sin_</span><span class="p">);</span>
 
    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* Port number. */</span>
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* Internet address. */</span>
    <span class="cm">/* Pad to size of `struct sockaddr'. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">)</span> <span class="o">-</span> 
    <span class="n">__SOCKADDR_COMMON_SIZE</span> <span class="o">-</span> 
    <span class="k">sizeof</span> <span class="p">(</span><span class="n">in_port_t</span><span class="p">)</span> <span class="o">-</span> 
    <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)];</span>
<span class="p">};</span>
<span class="cm">/* Structure describing a generic socket 
address. */</span>
<span class="k">struct</span> <span class="n">sockaddr</span>
<span class="p">{</span>
     <span class="n">__SOCKADDR_COMMON</span> <span class="p">(</span><span class="n">sa_</span><span class="p">);</span> <span class="cm">/* Common data: address family and length. */</span>
     <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* Address data. */</span>
<span class="p">};</span></code></pre></figure>

<p>可以看出书中sockaddr.sa_len和sockaddr_in.sin_len在ubuntu的版本中被去掉了。其余的结构都是一样的。<br />
sockaddr_in是IPv4套接口地址的结构，也叫”Internet socket address structure”，POSIX标准中要求其必须含有3个成员，sin_family,sin_port和sin_addr，后两个我们已经知道了他们的大小，sin_family的类型为unsiged short，可能会随着操作系统的不同会有所改变。<br />
第10行，socket函数<br />
用来创建一个新的socket，如果成功，则返回socket的文件描述符，如果失败，则可以根据返回的负数来查询相应的错误。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Create a new socket of type TYPE in domain DOMAIN, using protocol 
PROTOCOL. If PROTOCOL is zero, one is chosen automatically. 
Returns a file descriptor for the new socket, or -1 for errors. 
*/</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">socket</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__protocol</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span></code></pre></figure>

<p>domain参数表示通信的域，一般是指定通信的协议族，比如PF_INET/AF_INET表示IPv4协议，PF_INET6/AF_INET6表示IPv6协议，PF_UNIX/PF_LOCAL/AF_UNIX/AF_LOCAL UNIX表示进程通信协议；type表示socket的类型，比如SOCK_STREAM 提供双向连续且可信赖的数据流，即TCP，SOCK_DGRAM 使用不连续不可信赖的数据包连接，UDP；protocol指定在socket中使用的特定的协议。一般来讲，只存在一个单独的协议来支持给定的协议族中特定的socket类型，<br />
在这种情况下protocol可以用0来代表默认值。然而，有可能很多协议都会存在，在这种情况下特定的协议必须在这种方式下指定。我去源码中找了一下，发现了下面的协议编号。可以根据网络的环境进行选择。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="cm">/* Standard well-defined IP protocols. */</span>
    <span class="k">enum</span> <span class="p">{</span>
    <span class="n">IPPROTO_IP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/*     Dummy protocol for TCP */</span>
    <span class="n">IPPROTO_ICMP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Internet Control Message     Protocol */</span>
    <span class="n">IPPROTO_IGMP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* Internet Group Management Protocol     */</span>
    <span class="n">IPPROTO_IPIP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* IPIP tunnels (older KA9Q tunnels use 94)     */</span>
    <span class="n">IPPROTO_TCP</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* Transmission Control Protocol */</span>
    <span class="n">IPPROTO_EGP</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/* Exterior Gateway Protocol */</span>
    <span class="n">IPPROTO_PUP</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="cm">/* PUP protocol */</span>
    <span class="n">IPPROTO_UDP</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="cm">/* User Datagram Protocol */</span>
    <span class="n">IPPROTO_IDP</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="cm">/* XNS IDP protocol */</span>
    <span class="n">IPPROTO_DCCP</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span> <span class="cm">/* Datagram Congestion Control Protocol */</span>
    <span class="n">IPPROTO_RSVP</span> <span class="o">=</span> <span class="mi">46</span><span class="p">,</span> <span class="cm">/* RSVP protocol */</span>
    <span class="n">IPPROTO_GRE</span> <span class="o">=</span> <span class="mi">47</span><span class="p">,</span> <span class="cm">/* Cisco GRE tunnels (rfc 1701,1702) */</span>
    <span class="n">IPPROTO_IPV6</span> <span class="o">=</span> <span class="mi">41</span><span class="p">,</span> <span class="cm">/* IPv6-in-IPv4 tunnelling */</span>
    <span class="n">IPPROTO_ESP</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="cm">/* Encapsulation Security Payload protocol */</span>
    <span class="n">IPPROTO_AH</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span> <span class="cm">/* Authentication Header protocol*/</span>
    <span class="n">IPPROTO_BEETPH</span> <span class="o">=</span> <span class="mi">94</span><span class="p">,</span> <span class="cm">/* IP option pseudo header for BEET */</span>
    <span class="n">IPPROTO_PIM</span> <span class="o">=</span> <span class="mi">103</span><span class="p">,</span> <span class="cm">/* Protocol Independent Multicast */</span>
    <span class="n">IPPROTO_COMP</span> <span class="o">=</span> <span class="mi">108</span><span class="p">,</span> <span class="cm">/* Compression Header protocol */</span>
    <span class="n">IPPROTO_SCTP</span> <span class="o">=</span> <span class="mi">132</span><span class="p">,</span> <span class="cm">/* Stream Control Transport Protocol */</span>
    <span class="n">IPPROTO_UDPLITE</span> <span class="o">=</span> <span class="mi">136</span><span class="p">,</span> <span class="cm">/* UDP-Lite (RFC 3828) */</span>
    <span class="n">IPPROTO_RAW</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="cm">/* Raw IP packets */</span>
    <span class="n">IPPROTO_MAX</span>
    <span class="p">};</span>
    </code></pre></figure>

<p>第12行，bzero函数不知道是不是标准c的一部分，这个函数就是给一段字符串赋0值，比如</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">bzero</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="o">//</span><span class="err">相当于</span><span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span></code></pre></figure>

<p>这一行代码的作用是将servaddr中的内容全部置零。<br />
第13行，指定通信地址的协议族。<br />
第14行，指定通信地址的端口。这里有个htons函数，和这个函数类似的函数还有htonl,ntohs,ntohl,这一系列函数中，h代表host，也就是主机，to是转换，n是network，网络，l代表long，s代表short，这里的host和network应该怎么理解，这其实牵扯到主机字节顺序(Host Byte Order)和网络字节顺序(Network Byte Order)这两个概念有关。现在的CPU有两大派系，PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用big endian方式存储数据，而x86系列则采用little endian方式存储数据。Big-Endian表示高字节存放在最后(Big End first)，Little-Endian表示低字节放在最后(Litter End first)，举例来说：比如一个数字0x12345678,Big-Endian形式下这4个字节在内存中存放的顺序是<br />
|12|34|56|78|<br />
而Little-Endian形式的为<br />
|78|56|34|12|<br />
网络上的传输采用的是Big-Endian类型的，所以将本地的数字在进行网络传输之前要先进行转换，利用的就是上面提到的几个函数。<br />
第15行，赋值通信的ip地址。这里有个函数<code class="highlighter-rouge">inet_pton(int family,const char * strptr,void * addrptr);</code>就是将点分十进制串转换成网络字节序二进制值，同样要指定下协议族。<br />
第17行，<code class="highlighter-rouge">connect(sockfd,(SA*)&amp;servaddr,sizeof(servaddr))</code>，建立一个指定地址的连接。连接的服务器地址为servaddr。这里先给出它的声明<code class="highlighter-rouge">int connect(int sockfdFD,struct sockaddr*,int addrlength);</code><br />
这里就有一个问题，我们是把一个sockaddr_in类型的数据强制转换成了sockaddr类型。其实sockaddr的存储结构和sockaddr_in的存储结构是一样的，sockaddr是通用套接口地址结构(Generic Socket Address Structure)，而sockaddr_in可以看作是sockaddr的一个子集，至于后面的in的含义，我猜是internet的意思。这也解释了为什么sockaddr_in中会有冗余的数据，就是为了将结构体的大小设置成和sockaddr相等。而sockaddr.sa_data中数据可以看作是一种协议地址，不同协议所会有差别，这本书主要讲Internet协议。<br />
第19行，read函数其实是系统函数，从指定的文件读取数据，这里的文件描述符是创建socket时返回的描述符，也就是从网络读取。这也反映了在Unix系统中一切都是文件的思想。<br />
剩下的内容都很容易理解了，都是写基本的C语言的语法。<br />
上面的文件只是一个获取服务器时间的客户端代码，那么服务器端肯定要首先有这个服务，服务器端的代码如下：</p>

<p>daytimetcpsrv.c</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include "unp.h" 
#include &lt;time.h&gt; 
</span><span class="kt">int</span> 
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span> 
    <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span> 
    <span class="kt">time_t</span> <span class="n">ticks</span><span class="p">;</span> 
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span> 
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> <span class="cm">/* daytime server */</span> 
    <span class="n">Bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span> 
    <span class="n">Listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> 
        <span class="n">snprintf</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="s">"%.24srn"</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">));</span> 
        <span class="n">Write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span> 
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span> 
    <span class="p">}</span> 
<span class="p">}</span> </code></pre></figure>

<p>这段代码里面又出现了几个新函数。<br />
第15行，<code class="highlighter-rouge">int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);</code>函数，这个函数将socket绑定到网络地址，对于Internet来说，就是ip地址和端口号，每个socket在正常工作前都要进行这种绑定，那么现在看daytimetcpcli.c中的代码中并没有发现这个函数，原因是这样的，如果你没有手动进行绑定，那么系统会在运行的时候绑定本机地址和一个临时的端口，但是这对于客户来说用那个端口是无所谓的，但是如果服务器绑定了一个临时的端口，客户并不知道是那个端口，就没法连接了，所以服务端要绑定一个特定的端口，并和服务器说，你来连接这个端口，这样才会正常的工作。现在看这个socket绑定的地址和端口都是什么，端口是13，这个号理解，但是地址是INADDR_ANY，这是什么意思？因为有可能我的这个服务器有很多网卡，有很多IP地址，我想不管是那个IP地址接受到的数据，只要是通过13端口连接的，我都处理，这时候就可以通过绑定INADDR_ANY来实现。<br />
第16行，int listen(int sockfd, int backlog)，这个函数是使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。因为当一个socket建立时，默认是主动的，也就是说准备去连接服务器的，但是调用listen后，会将这个socket变成被动，准备接受来自其他socket的连接。一般这个函数只会在服务器端出现。第二个参数是指内核为此套接字排队的最大连接个数。比如很多客户端尝试着连接这个socket，服务器无法快速的完成所有的请求，那么就会维护一个队列。这里指定的值为LISTENQ，这里为1024.<br />
第18行，<code class="highlighter-rouge">int accept(int sockfd, struct sockaddr* addr, socklen_t* len)</code>，接受来自sockaddr的连接，如果成功则返回一个全新的文件描述符，代表与客户的网络连接，后面的代码可以看到怎么处理的这个新的文件描述符，需要注意的是，accept函数默认会阻塞进程，也就是说连接成功后程序才会往下执行。<br />
分析了这两个代码可以基本了解整个连接是怎么建立起来的了：</p>

<ol>
  <li>
    <p>服务器端建立一个标识为listenfd的套接字。</p>
  </li>
  <li>
    <p>将listenfd这个套接字绑定到13端口。</p>
  </li>
  <li>
    <p>将listenfd变成被动的socket接口。</p>
  </li>
  <li>
    <p>利用accept函数让listenfd这个套接字来等待客户的连接，服务器端阻塞。</p>
  </li>
  <li>
    <p>服务器建立标识为sockfd的socket，这个socket并没有手动绑定。系统会用本机地址和一个随机的端口对其绑定。</p>
  </li>
  <li>
    <p>将sockfd这个套接字通过connect与服务器地址相连接。如果连接成功，则read函数准备读取这个sockfd的数据，客户端阻塞。</p>
  </li>
  <li>
    <p>服务器端接收到请求，生成一个新的socket与客户端相连接connfd。</p>
  </li>
  <li>
    <p>服务器通过新生成的socket发送给客户端数据。</p>
  </li>
  <li>
    <p>客户端通过与服务器相连接的socket读取到了数据并显示，结束。</p>
  </li>
</ol>

<p><img src="/images/unp/005_thumb.png" alt="image" />
其实是两台电脑通过socket进行了进程间通信，代码中是通过文件描述符来代表socket的，至于socket的结构以及怎么就能通过这个socket进行数据传输，这些内容有待研究。</p>



    </article>
    <span class="print-footer">Unix Network Programming 读书笔记1:daytimetcp注解 - December 30, 2011 - </span>
    <footer>
  <hr class="slender">
  <!-- <ul class="footer&#45;links"> -->
  <!--   <li><a href="mailto:hate@spam.net"><span class="icon&#45;mail"></span></a></li>     -->
  <!--    -->
  <!--     <li> -->
  <!--       <a href="//www.twitter.com/twitter_handle"><span class="icon-twitter"></span></a> -->
  <!--     </li> -->
  <!--    -->
  <!--     <li> -->
  <!--       <a href="//plus.google.com/+googlePlusName"><span class="icon-googleplus"></span></a> -->
  <!--     </li> -->
  <!--    -->
  <!--     <li> -->
  <!--       <a href="//github.com/GithubHandle"><span class="icon-github"></span></a> -->
  <!--     </li> -->
  <!--    -->
  <!--     <li> -->
  <!--       <a href="//www.flickr.com/photos/FlickrUserID"><span class="icon-flickr"></span></a> -->
  <!--     </li> -->
  <!--    -->
  <!--     <li> -->
  <!--       <a href="/feed"><span class="icon-feed"></span></a> -->
  <!--     </li> -->
  <!--      -->
  <!-- </ul> -->
<div class="credits">
<!-- <span>&#38;copy; 2018 <!&#45;&#45; &#38;#38;nbsp;&#38;#38;nbsp; &#45;&#45;></span></br> <br> -->
<span>Site created with <a href="//jekyllrb.com">Jekyll</a> using the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a>, based on <a href="//github.com/ermongroup/cs228-notes">Ermongroup</a>. &copy; 2018</span> 
</div>  
</footer>

  </body>
</html>
